<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particles - Epic Glow Version</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- –î–û–ë–ê–í–õ–Ø–ï–ú –í–°–ï –ù–ï–û–ë–•–û–î–ò–ú–´–ï –ë–ò–ë–õ–ò–û–¢–ï–ö–ò -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/shaders/LuminosityShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/shaders/ConvolutionShader.js"></script>

    <script>
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
        document.body.appendChild(renderer.domElement);

        // –ü–ê–†–ê–ú–ï–¢–†–´ –°–ò–°–¢–ï–ú–´
        const config = {
            centerParticles: 6000,  // –£–º–µ–Ω—å—à–∏–ª –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            ringCount: 6,
            particlesPerRing: 8000, // –£–º–µ–Ω—å—à–∏–ª –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            baseRadius: 3,
            ringSpacing: 1.4,
            thickness: 1.4
        };

        // –ì–†–£–ü–ü–´ –î–õ–Ø –†–ê–ó–î–ï–õ–¨–ù–û–ì–û –í–†–ê–©–ï–ù–ò–Ø
        const centerGroup = new THREE.Group(); // –î–ª—è —Å—Ñ–µ—Ä—ã
        const ringsGroup = new THREE.Group();  // –î–ª—è –≤—Å–µ—Ö –∫–æ–ª–µ—Ü
        scene.add(centerGroup);
        scene.add(ringsGroup);

        // –®–ï–ô–î–ï–†–ù–´–ô –ú–ê–¢–ï–†–ò–ê–õ –î–õ–Ø –ò–î–ï–ê–õ–¨–ù–û –ö–†–£–ì–õ–´–• –ß–ê–°–¢–ò–¶
        const createParticleMaterial = (isCenter = false) => {
            const vertexShader = `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const fragmentShader = `
                varying vec3 vColor;
                
                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float distance = length(coord);
                    
                    // –ò–¥–µ–∞–ª—å–Ω–æ –∫—Ä—É–≥–ª—ã–µ —á–∞—Å—Ç–∏—Ü—ã —Å –º—è–≥–∫–∏–º–∏ –∫—Ä–∞—è–º–∏
                    if (distance > 0.5) {
                        discard;
                    }
                    
                    // –ü–ª–∞–≤–Ω—ã–µ –∫—Ä–∞—è –¥–ª—è –º—è–≥–∫–æ–≥–æ –≤–∏–¥–∞
                    float alpha = 1.0 - smoothstep(0.4, 0.5, distance);
                    ${isCenter ? 'alpha *= 0.9;' : 'alpha *= 0.8;'}
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º glow —ç—Ñ—Ñ–µ–∫—Ç
                    float glow = exp(-distance * 44.0) * 0.5;
                    alpha += glow;
                    
                    gl_FragColor = vec4(vColor, alpha);
                }
            `;

            return new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
        };

        // –ú–ê–°–°–ò–í–´ –î–õ–Ø –ß–ê–°–¢–ò–¶
        const centerPositions = [];
        const centerColors = [];
        const centerSizes = [];

        // 1. –°–û–ó–î–ê–ï–ú –¶–ï–ù–¢–†–ê–õ–¨–ù–£–Æ –°–§–ï–†–£
        for (let i = 0; i < config.centerParticles; i++) {
            // –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ —Å—Ñ–µ—Ä–µ
            const phi = Math.acos(1 - 2 * (i + 0.5) / config.centerParticles);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);

            const radius = 1.2 + Math.random() * 0.7;

            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            centerPositions.push(x, y, z);

            // –°–∏–Ω–µ-—Ñ–∏–æ–ª–µ—Ç–æ–≤–∞—è –≥–∞–º–º–∞
            const hue = 0.65 + Math.random() * 0.25;
            const saturation = 0.8 + Math.random() * 0.2;
            const color = new THREE.Color().setHSL(hue, saturation, 0.6);
            centerColors.push(color.r, color.g, color.b);

            centerSizes.push(0.08 + Math.random() * 0.12);
        }

        // –ì–µ–æ–º–µ—Ç—Ä–∏—è –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π —Å—Ñ–µ—Ä—ã
        const centerGeometry = new THREE.BufferGeometry();
        centerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(centerPositions, 3));
        centerGeometry.setAttribute('color', new THREE.Float32BufferAttribute(centerColors, 3));
        centerGeometry.setAttribute('size', new THREE.Float32BufferAttribute(centerSizes, 1));

        const centerMaterial = createParticleMaterial(true);
        const centerParticles = new THREE.Points(centerGeometry, centerMaterial);
        centerGroup.add(centerParticles);

        // 2. –°–û–ó–î–ê–ï–ú –ö–û–õ–¨–¶–ê –ü–û–î –†–ê–ó–ù–´–ú–ò –£–ì–õ–ê–ú–ò
        const rings = [];

        // –£–≥–ª—ã –Ω–∞–∫–ª–æ–Ω–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–ª—å—Ü–∞ (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö)
        const ringAngles = [
            Math.PI / 2,    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ
            Math.PI / 4,    // –ü–æ–¥ 45 –≥—Ä–∞–¥—É—Å–æ–≤
            -Math.PI / 4,   // –ü–æ–¥ -45 –≥—Ä–∞–¥—É—Å–æ–≤
            Math.PI / 3,    // –ü–æ–¥ 60 –≥—Ä–∞–¥—É—Å–æ–≤  
            -Math.PI / 3,   // –ü–æ–¥ -60 –≥—Ä–∞–¥—É—Å–æ–≤
            0               // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ
        ];

        for (let ringIndex = 0; ringIndex < config.ringCount; ringIndex++) {
            const ringGroup = new THREE.Group();
            const ringPositions = [];
            const ringColors = [];
            const ringSizes = [];

            const radius = config.baseRadius + ringIndex * config.ringSpacing;
            const tiltAngle = ringAngles[ringIndex % ringAngles.length];

            for (let j = 0; j < config.particlesPerRing; j++) {
                const angle = (j / config.particlesPerRing) * Math.PI * 2;

                // –ë–∞–∑–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ XZ
                const radiusVariation = radius + (Math.random() - 0.5) * config.thickness;
                const baseX = Math.cos(angle) * radiusVariation;
                const baseY = (Math.random() - 0.5) * config.thickness * 0.5;
                const baseZ = Math.sin(angle) * radiusVariation;

                // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞–∫–ª–æ–Ω –∫–æ–ª—å—Ü–∞
                const x = baseX;
                const y = baseY * Math.cos(tiltAngle) - baseZ * Math.sin(tiltAngle);
                const z = baseY * Math.sin(tiltAngle) + baseZ * Math.cos(tiltAngle);

                ringPositions.push(x, y, z);

                // –¶–≤–µ—Ç –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–æ–ª—å—Ü–∞
                const hue = (ringIndex / config.ringCount) * 0.8 + 0.1;
                const saturation = 0.9;
                const lightness = 0.6 + Math.random() * 0.2;
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                ringColors.push(color.r, color.g, color.b);

                ringSizes.push(0.06 + Math.random() * 0.1);
            }

            const ringGeometry = new THREE.BufferGeometry();
            ringGeometry.setAttribute('position', new THREE.Float32BufferAttribute(ringPositions, 3));
            ringGeometry.setAttribute('color', new THREE.Float32BufferAttribute(ringColors, 3));
            ringGeometry.setAttribute('size', new THREE.Float32BufferAttribute(ringSizes, 1));

            const ringMaterial = createParticleMaterial(false);
            const ringParticles = new THREE.Points(ringGeometry, ringMaterial);
            ringGroup.add(ringParticles);
            ringsGroup.add(ringGroup);

            rings.push({
                group: ringGroup,
                speed: 0.03, // –û–î–ò–ù–ê–ö–û–í–ê–Ø —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –≤—Å–µ—Ö
                phase: ringIndex * 0.6 // –†–∞–∑–Ω–∞—è —Ñ–∞–∑–∞ –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
            });
        }

        // –ö–ê–ú–ï–†–ê
        camera.position.z = 20;

        // –î–æ–±–∞–≤–ª—è–µ–º —Ç—É–º–∞–Ω –¥–ª—è –≥–ª—É–±–∏–Ω—ã
        scene.fog = new THREE.Fog(0x000000, 10, 25);

        // –ü–õ–ê–í–ù–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ú–´–®–¨–Æ
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            targetRotationY = mouseX * Math.PI / 4;
            targetRotationX = mouseY * Math.PI / 8;
        });

        // üëá –ü–†–û–°–¢–ê–Ø –í–ï–†–°–ò–Ø –ë–ï–ó COMPOSER - –ß–¢–û–ë–´ –°–†–ê–ë–û–¢–ê–õ–û üëá
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // 1. –í–†–ê–©–ï–ù–ò–ï –¶–ï–ù–¢–†–ê–õ–¨–ù–û–ô –°–§–ï–†–´
            centerGroup.rotation.x = time * 0.1;
            centerGroup.rotation.y = time * 0.15;
            centerGroup.rotation.z = time * 0.05;

            // 2. –í–†–ê–©–ï–ù–ò–ï –í–°–ï–• –ö–û–õ–ï–¶ –° –û–î–ò–ù–ê–ö–û–í–û–ô –°–ö–û–†–û–°–¢–¨–Æ
            rings.forEach((ring, index) => {
                // –í—Ä–∞—â–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Å–≤–æ–µ–π –æ—Å–∏
                ring.group.rotation.y = time * ring.speed + ring.phase;

                // –õ–µ–≥–∫–æ–µ –∫–∞—á–∞–Ω–∏–µ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
                ring.group.rotation.x = Math.sin(time * 0.2 + index) * 0.2;
                ring.group.rotation.z = Math.cos(time * 0.3 + index) * 0.07;
            });

            // 3. –ü–õ–ê–í–ù–û–ï –í–†–ê–©–ï–ù–ò–ï –í–°–ï–ô –°–¶–ï–ù–´ –û–¢ –ú–´–®–ò
            ringsGroup.rotation.x += (targetRotationX - ringsGroup.rotation.x) * 0.05;
            ringsGroup.rotation.y += (targetRotationY - ringsGroup.rotation.y) * 0.05;

            // üëá –ü–†–û–°–¢–û–ô RENDER –ë–ï–ó GLOW üëá
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // üëá –î–û–ë–ê–í–¨ –≠–¢–û–¢ –ö–û–î –î–õ–Ø –í–´–°–û–ö–û–ì–û –†–ê–ó–†–ï–®–ï–ù–ò–Ø üëá

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –∑–∞–ø–∏—Å–∏
        const RECORD_RESOLUTION = {
            width: 3840,   // Full HD
            height: 2160,
            scale: 2       // –ú–∞—Å—à—Ç–∞–± –¥–ª—è —Å—É–ø–µ—Ä-—á–µ—Ç–∫–æ—Å—Ç–∏
        };

        let isRecording = false;
        let recorder = null;
        let recordedChunks = [];
        let originalSize = { width: window.innerWidth, height: window.innerHeight };

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
        function setRenderSize(width, height) {
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        // –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–ø–∏—Å–∏
        const recordButton = document.createElement('button');
        /*recordButton.innerHTML = '‚è∫Ô∏è –ó–∞–ø–∏—Å–∞—Ç—å –≤–∏–¥–µ–æ';
        recordButton.style.position = 'absolute';
        recordButton.style.top = '10px';
        recordButton.style.right = '10px';
        recordButton.style.zIndex = '1000';*/
        recordButton.style.padding = '10px 15px';
        recordButton.style.background = '#ff4444';
        recordButton.style.color = 'white';
        recordButton.style.border = 'none';
        recordButton.style.borderRadius = '5px';
        recordButton.style.cursor = 'pointer';
        recordButton.style.fontSize = '14px';
        document.body.appendChild(recordButton);

        // –§—É–Ω–∫—Ü–∏—è –Ω–∞—á–∞–ª–∞ –∑–∞–ø–∏—Å–∏
        async function startRecording() {
            try {
                const stream = renderer.domElement.captureStream(30); // 60 FPS
                recorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm; codecs=vp9',
                    videoBitsPerSecond: 48000000 // 48 Mbps - –≤—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
                });

                recordedChunks = [];

                recorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                recorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'particles-animation.webm';
                    a.click();
                    URL.revokeObjectURL(url);

                    recordButton.innerHTML = '‚è∫Ô∏è –ó–∞–ø–∏—Å–∞—Ç—å –≤–∏–¥–µ–æ';
                    recordButton.style.background = '#ff4444';
                    isRecording = false;
                };

                recorder.start(1000); // –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
                isRecording = true;
                recordButton.innerHTML = '‚èπÔ∏è –ò–¥–µ—Ç –∑–∞–ø–∏—Å—å...';
                recordButton.style.background = '#44ff44';

                // –ê–≤—Ç–æ—Å—Ç–æ–ø —á–µ—Ä–µ–∑ 15 —Å–µ–∫—É–Ω–¥
                setTimeout(() => {
                    if (isRecording) {
                        stopRecording();
                    }
                }, 45000);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏:', error);
                alert('–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∑–∞–ø–∏—Å—å. –ò—Å–ø–æ–ª—å–∑—É–π OBS Studio.');
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞–ø–∏—Å–∏
        function stopRecording() {
            if (recorder && isRecording) {
                recorder.stop();
            }
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏
        recordButton.addEventListener('click', () => {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });

        // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ –µ—Å–ª–∏ MediaRecorder –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
        function showAlternativeMethods() {
            const methodsDiv = document.createElement('div');
            methodsDiv.innerHTML = `
                <div style="position: absolute; top: 50px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 5px; z-index: 1000; max-width: 300px;">
                    <h4>üé• –°–æ–≤–µ—Ç—ã –ø–æ –∑–∞–ø–∏—Å–∏:</h4>
                    <p>1. <strong>OBS Studio</strong> - –ª—É—á—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç</p>
                    <p>2. <strong>Windows Game Bar</strong> - Win + G</p>
                    <p>3. <strong>Mac QuickTime</strong> - –∑–∞–ø–∏—Å—å —ç–∫—Ä–∞–Ω–∞</p>
                    <p>4. <strong>–ú–æ–±–∏–ª—å–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</strong> –¥–ª—è –∑–∞–ø–∏—Å–∏ —ç–∫—Ä–∞–Ω–∞</p>
                </div>
            `;
            document.body.appendChild(methodsDiv);

            setTimeout(() => {
                document.body.removeChild(methodsDiv);
            }, 10000);
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É MediaRecorder
        if (!MediaRecorder) {
            recordButton.innerHTML = 'üé• –ó–∞–ø–∏—Å—å (OBS)';
            recordButton.onclick = showAlternativeMethods;
        }

        // –ó–ê–ü–£–°–ö
        animate();
    </script>

</body>

</html>